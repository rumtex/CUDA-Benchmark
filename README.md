## модель персептрона

[картинка]

# описание

нейронная сеть может быть представлена в виде графа, который состоит из упорядоченных слоев
все вершины слоя связаны со всеми вершинами каждого из ближайших слоев и на них расположены коэффициенты (weight)

в процессе работы каждая вершина берет свой коэффициент, применяет на своем значении (docs/three_point_square_progression.ods) и голосует за то каким значением будет вершина на исходящем слое. Результаты суммируются, берется среднее арифметическое.

в процессе тренировки (на данный момент) мы считаем какое крайнее значение должно быть у коэффициента по вектору (input-middles-output) чтобы преобразовать бит и берем среднее арифметическое (ассиметричные задачки плакали с таким решением)

# варианты решения

```C++
enum training_mode_t {
    arithmetical_mean, // ищет среднее арифметическое значение для того чтобы задать нужный коэффициент КАЖДОМУ прошедшему нейрону в равной степени
    arithmetical_mean_v2, // среднее арифметическое с применением коэффициента близости к стороне входящей\исходящей вершины
    flash_mod, // создаем копию сетки. перебирая веса (или находя по градиентным функциям всяким) устанавливаем самые подходящие состояния, потом сравниваем их по очереди с оригиналом и выбираем вариант по пути наименьшей разницы. находим среднее или пересчитываем все с другой отправной точки
    backpropagation, // поиск всех ошибочных путей, исправление коэффициентов поштучно
}

```

# hello world

```C++
Perceptron P1 ({
        "Знаток \"ИЛИ\"", // название используется для сохранения состояния в файл
        { 2, 3, 1 },      // количественная характеристика слоев
        // какие-то параметры
        .float_generator = random_sign_float_unit_fraction,
        .validator = validate_result
    });

// обучение таблице истинности операции OR
P1.train({
    {{true, true},{true}},
    {{true, false},{true}},
    {{false, true},{true}},
    {{false, false},{false}},
});


bool* result = P1.run({true, true});
```
