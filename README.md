##модель персептрона

[картинка]

#описание

нейронная сеть может быть представлена в виде графа, который состоит из упорядоченных слоев
все вершины слоя связаны со всеми вершинами каждого из ближайших слоев и на них расположены коэффициенты (weight)

в процессе работы каждая вершина берет свой коэффициент, применяет на своем значении (docs/three_point_square_progression.ods) и голосует за то каким значением будет вершина на исходящем слое. Результаты суммируются, берется среднее арифметическое.

в процессе тренировки (на данный момент) мы считаем какоt крайнее значение должно быть у коэффициента по вектору (input-middles-output) чтобы преобразовать бит и берем среднее арифметическое (ассиметричные задачки плакали с таким решением)

#варианты решения

```C++
enum training_mode_t {
    arithmetical_mean, // ищет среднее арифметическое значение для того чтобы задать нужный коэффициент КАЖДОМУ прошедшему нейрону в равной степени
    arithmetical_mean_v2, // среднее арифметическое с применением коэффициента близости к стороне входящей\исходящей вершины
    progression_second_layer, // вторым слоем представлена прогрессия от минимума до максимума (и чтото не так по краям)
}

```

#hello world

```C++
Perceptron P1 ({
        "Знаток \"ИЛИ\"", // название используется для сохранения состояния в файл
        { 2, 3, 1 },      // количественная характеристика слоев
        // какие-то параметры
        .float_generator = random_sign_float_unit_fraction,
        .validator = validate_result
    });

// обучение таблице истинности операции OR
P1.train({
    {{true, true},{true}},
    {{true, false},{true}},
    {{false, true},{true}},
    {{false, false},{false}},
});


bool* result = P1.run({true, true});
```